分层模型
|OSI 七层|	TCP/IP 四层|* TCP/IP 五层	|主要协议|主要职责|
|-----|------------|---------------|-----|----------|
|应用层|	→ 应用层	|→ 应用层	|HTTP, DNS, SMTP, FTP| 用户交互、数据语义|
|表示层	|↗	|↗	| | |
|会话层	|↗	|↗	| | |
|传输层	|→ 传输层	|→ 传输层	|TCP, UDP| 端到端通信、可靠性|
|网络层	|→ 网络层	|→ 网络层	|IP, ICMP, OSPF, BGP| 路由、寻址、跨网段	|
|数据链路层	|↘ 网络接口层	|→ 数据链路层	|Ethernet, Wi-Fi, PPP, ARP|局域网帧传输、MAC 地址	| 
|物理层	|↘ 网络接口层	|→ 物理层	|双绞线、光纤、无线电波、USB| 电信号、光信号、比特流|

网络模型：C/S模型(client-server)和B/S模型(browser-server)
|    |C/S模型(client-server)|B/S模型(browser-server)|
|-----|--------------------|------------------------|
|优点|缓存大量数据、协议选择灵活、速度快|安全性高、跨平台、开发工作量小|
|缺点|安全性不好、不能跨平台、开发工作量大|不能缓存大量数据、严格遵循http|
# 物理层

# 数据链路层
## ARP、RARP协议
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/5c31c69a-a7ab-448d-afff-82d0f3ac80f1)
# 网络层
## IP
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/2d9bfb90-c911-4732-9239-895b27917f18)
## NAT 网络地址转换
NAT(Network Address Translation)通过将私有IP地址转换为公共IP地址，使多个内部设备能够共享一个或多个公共IP地址访问互联网（解决 IPv4 地址枯竭问题）。私有IP地址通常用于局域网中，不能直接在互联网中路由，而公共IP地址由ISP分配，用于标识设备在互联网中的位置。

NAT 设备（通常是路由器）位于内网与公网之间，当数据包经过时：

- 出站数据包（内网 → 外网）：
    - 修改源 IP 地址为公网 IP；
    - 可选：修改源端口号（PAT 场景）；
    - 在 NAT 表中记录映射关系。
- 入站数据包（外网 → 内网）：
    - 根据目标 IP 和端口查询 NAT 表；
    - 找到对应内网 IP 和端口；
    - 修改目标地址并转发给内网主机。
>NAT转换表（NAT Table）:
存储“内网IP:端口 ↔ 公网IP:端口”的映射关系
### 主要分类

|特性	|静态 NAT	|动态 NAT|	【最常用】PAT（NAPT）|
|-------|--------|--------|-------------|
|映射关系	|1:1 固定|	N:M 临时（IP池）|	N:1（IP+端口）|
|是否转换端口	|❌ 否|	❌ 否|	✅ 是|
|是否节省公网 IP|	❌ 否	|❌ 部分节省（仍需多IP）|	✅✅ 是（一个IP支持多设备）|
|外部可访问性|	✅ 可（如服务器）|	⚠️ 临时可	|❌ 默认不可（除非端口映射）|

#### 静态NAT
静态NAT（Static NAT）是一种一对一的地址转换方式，将一个私有IP地址映射为一个固定的公共IP地址。每个内部设备都对应一个唯一的公共IP地址。
#### 动态NAT
动态NAT（Dynamic NAT）是一种多对多的地址转换方式，将多个私有IP地址动态映射为多个公共IP地址。NAT设备维护一个地址池，并根据需要分配公共IP地址。
#### 端口地址转换（PAT）
端口地址转换（Port Address Translation 也称 NAT Overload）是一种多对一的地址转换方式，允许多个私有 IP 地址共享一个公网 IP 地址；NAT 设备通过为每个“私有IP:端口”分配唯一的“公网IP:端口”映射来区分不同会话 —— 无论是来自不同主机，还是同一主机的不同源端口
端口号有限制【端口号16位，支持的最大主机数约为216】，过多的连接可能导致端口耗尽。

### 行为分类
<img width="654" height="368" alt="image" src="https://github.com/user-attachments/assets/0be9d37d-c0c1-4603-9bd0-452ece69a13a" />

- 锥型 NAT（Cone）：
    - 映射键 = 内网 IP:Port
    - 无论访问多少外部目标，只要“内网IP:Port”相同 → 尽量使用同一个公网端口
    - 外部能否访问取决于“锥型子类”（完全/限制/端口限制）
-  对称型 NAT（Symmetric）：
    - 映射键 = 内网 IP:Port + 外网 IP:Port
    - 同一个“内网IP:Port”，访问不同目标 → 分配不同公网端口

|类型	|映射是否复用端口？|	外部访问限制|	穿透难度|
|-------|--------|--------|-------------|
|完全锥型|	是（固定端口）|	无限制，任意 IP:Port 可访问	|⭐⭐⭐⭐⭐	|
|限制型锥型	|是	|仅访问过的 IP（任意端口）可访问	|⭐⭐⭐⭐	|
|端口限制型锥型	|是	|仅访问过的 IP:Port 可访问	|⭐⭐⭐	|
|对称型 NAT	|❌ 否（不同目标用不同端口）|	仅原目标 IP:Port 可回包	|⭐|

假定：
>公网server1：ip是1.1.1.1，监听端口是1111
公网server2：ip是2.2.2.2，监听端口是2222
NAT网关：ip是3.3.3.3
NAT内部需要穿透的电脑A：内网ip是：192.168.0.2
A（192.168.0.2:100）已经通过NAT网关（3.3.3.3:200）和server1（1.1.1.1:1111）建立了链接

#### 完全锥型
（Full Cone NAT）一旦映射建立，任何外部主机（无论 IP 和端口）都可以向 3.3.3.3:200发送数据包，NAT网关就会接收数据包并将其转发到内部的192.168.0.2:100上
#### ip限制型锥型
（Restricted Cone NAT）只有 A 曾经发送过数据包的“外部 IP”，才能从任意端口向 P 发包并被转发给 A。例如此刻如果server1想通过1112这个端口和A再建立一个连接，那么只需要往3.3.3.3:200发送数据，NAT会正常的将其转发到192.168.0.2:100，但是如果此刻server2想和A建立连接，因为server2在此前并未和A建立连接，所以如果server2给3.3.3.3:200发送数据的话，NAT网关会将来自server2的数据包直接丢弃。
#### 端口限制型锥型 NAT
（Port-Restricted Cone NAT）只有 A 曾经发送过数据包的“外部 IP + 端口”，才能向 P 发包并被转发。在ip限制型锥型的基础上，再进行端口的限制，也就是说现在不只对ip有需求，连端口都有需求，如果按照上面的例子，此刻如果server1还想通过1112端口和A建立连接就不行了，因为限制了端口，只有从1.1.1.1:1111发来的数据NAT网关才会处理
#### 对称型 NAT
（Symmetric NAT）同一个内网 IP:Port，访问不同的外网目标，会映射到不同的公网端口
即：映射关系是 “内网IP:Port + 外网IP:Port” → “公网IP:Port”
# 传输层
## UDP

## TCP
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/17052f06-b147-4e7e-8499-179dc2e242f0)

![image](https://github.com/user-attachments/assets/db374e2d-7ed9-4970-a193-1d333387b07f)

### 三次握手与四次挥手
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/3d7ab297-aa22-4872-885c-07e630ba3ae9)

![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/4cd91623-cda9-426c-83f9-ad7853ff00ec)

socket套接字中有两个(读、写)缓冲区 半关闭就是关闭了其中一个写缓冲区
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/55163018-cfea-44eb-8f63-c368101450d0)

TCP状态转移图
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/12c270d9-53d1-4d57-8dfd-9d7b12503155)

## RTCP
### NACK
FMT 和 PT 决定了该报文的类型，FCI 则是该类型报文的具体负载 NACK 反馈报文的 PT= 205，FMT=1
<img width="720" height="267" alt="image" src="https://github.com/user-attachments/assets/c2d833c2-a1a4-40a5-aa54-14ef27c5bee7" />

每个FCI 的格式如下（可以附带多个 FCI，通过 header 的 length 字段来标示其长度）：
<img width="1008" height="192" alt="image" src="https://github.com/user-attachments/assets/7d378625-a753-4edc-83e0-59ab82520d8e" />
- PID（Packet identifier），即为丢失的 RTP 数据包的序列号
- BLP（Bitmao of Lost Packets），通过掩码的方式指出了接下来 16 个数据包的丢失情况

c++解析
```c++
// ✅ 使用 getSize() 计算 FCI 块数量
size_t total_bytes = rtcp->getSize();  // 整个 RTCP 包的字节数
if (total_bytes < 12) {
    WarnL << "Invalid RTCP packet size: " << total_bytes;
    break;
}

size_t fci_bytes = total_bytes - 12;  // 减去 4(header) + 4(sender_ssrc) + 4(media_ssrc)
if (fci_bytes == 0 || fci_bytes % 4 != 0) {
    WarnL << "Invalid FCI size: " << fci_bytes << " bytes";
    break;
}

int fci_count = fci_bytes / 4;  // 每个 FCI_NACK 占 4 字节
if (fci_count > 100) { // 添加合理上限检查
    WarnL << "Suspiciously large FCI count: " << fci_count;
    break;
}
InfoL << "Received NACK for media ssrc=" << media_ssrc 
    << ", FCI blocks=" << fci_count;

// --- 🔽 添加：解析并打印 NACK 请求的包序列号 ---
// uint8_t *fci_data = (uint8_t *)(fb + 1);

// 先存储所有请求的NACK序号
std::unordered_set<uint16_t> requested_seq;
uint8_t *fci_data = reinterpret_cast<uint8_t*>(fb) + sizeof(RtcpFB);
std::ostringstream oss;
oss << "NACK requested packets: ";

for (int i = 0; i < fci_count; ++i) {
    uint8_t *ptr = fci_data + i * 4;
    
    // 使用ntohs确保正确的字节序处理
    uint16_t pid = ntohs(*reinterpret_cast<uint16_t*>(ptr));
    uint16_t blp = ntohs(*reinterpret_cast<uint16_t*>(ptr + 2));
    requested_seq.insert(pid);

    oss << "[" << pid;
    for (int j = 0; j < 16; ++j) {
        if (blp & (1 << j)) {
            oss << "," << (pid + 1 + j);
            requested_seq.insert(pid + 1 + j);
        }
    }
    oss << "] ";
}

DebugL << oss.str();
```
# 应用层
## DNS
## STUN 
STUN (Session Traversal Utilities for NAT)基于 UDP 或 TCP传输，默认端口 3478, 不参与数据传输本身，而是帮助应用程序“发现 NAT 行为”，从而建立 P2P 连接
### 功能
让位于NAT（防火墙）后的客户端发现自己网络的“公网IP:端口”映射对。客户端向公网上的STUN服务器发送一个请求，服务器会回复：“我从哪个公网地址收到了你的请求”。这样，客户端就知道了它在公网上的“联系方式”
- 发现自己的公网 IP 地址和端口（即“NAT 映射后的地址”）；
- 判断自己所处的 NAT 类型（锥型 or 对称型？）；
- 辅助建立点对点（P2P）连接。
>DNS：帮助你“发现 IP 地址” → 为网络层服务；
STUN：帮助你“发现公网地址和 NAT 类型” → 为传输层 P2P 通信服务

STUN 本身不穿透 NAT，它只是“探测和报告”NAT 行为，真正的穿透靠应用程序逻辑或 ICE 协议。
STUN + ICE 可穿透所有锥型 NAT，但对称型 NAT 需要 TURN 中继

### 工作原理
- 1. A 向公网 STUN 服务器（如 stun.l.google.com:3478）发送一个 UDP 请求包；
- 2. STUN 服务器收到包，查看“源 IP:Port”（这是 A 的公网映射地址，如 203.0.113.1:60001）；
- 3. STUN 服务器在响应包中，把 203.0.113.1:60001 告诉 A；
- 4. A 得知：“哦，我在公网的地址是 203.0.113.1:60001”；
- 5. （可选）A 可以再发几次包到不同 IP/Port，测试 NAT 是否复用端口 → 判断 NAT 类型（锥型 or 对称型）。

### STUN 消息结构
```
STUN 消息 = Header + Attributes
Attributes 包含：
  - MAPPED-ADDRESS：你的公网IP:Port
  - XOR-MAPPED-ADDRESS（新版 STUN（RFC 5389））：加密混淆后的地址 防止中间设备篡改
  - ERROR-CODE（如有错误）
  - SOFTWARE（服务器信息）
  - 等等...
```
## TURN
TURN (Traversal Using Relays around NAT) 基于 UDP/TCP/TLS over TCP 或 DTLS传输，默认端口	UDP/TCP 3478，TLS 5349。允许位于严格 NAT（如对称型 NAT）后的客户端，通过公网上的 TURN 服务器中转数据，实现与对端的通信
### 功能
提供一个“公网可达的中继服务器”，A 和 B 都连接到它，所有数据通过它转发，TURN 服务器维护“谁在跟谁通信”的权限表（防止滥用）
### 工作原理
设备 A（内网）和设备 B（内网）无法直连，需通过 TURN 服务器中继通信
1. A 向 TURN 服务器申请“中继地址”
    - A 发送 Allocate 请求（需认证，如用户名/密码或 Token）；
    - TURN 服务器分配一个“中继 IP:Port”（如 185.10.10.1:50000）；
    - 此地址对公网开放，B 可以向它发包。
2. A 告诉 B：“你可以通过 185.10.10.1:50000 找我”
（通常通过信令服务器传递，如 WebSocket、SIP、HTTP）

3. B 向 TURN 服务器的中继地址发包
    - 包到达 TURN 服务器；
    - TURN 查表 → 这是给 A 的 → 转发给 A 的真实地址（通过已建立的 UDP/TCP 隧道）；
4. A → B 的数据也同理：
    - A 发给 TURN 服务器，指明目标是 B；
    - TURN 转发给 B。

### TURN 消息类型
|消息类型	|作用|
|---------|----|
|Allocate	|申请一个中继地址（端口）|
|Refresh	|延长中继地址租期（默认 10 分钟）|
|Send / Data	|发送数据给对端（通过中继）|
|CreatePermission	|授权某个 IP:Port 可以向你发数据（安全控制）|
|ChannelBind	|建立“通道”，用短 ID 代替 IP:Port，减少开销（可选）|
## HTTP
<img width="820" height="888" alt="image" src="https://github.com/user-attachments/assets/9aba8eb9-85ee-4739-981d-d541e674caaf" />
<img width="768" height="906" alt="image" src="https://github.com/user-attachments/assets/a01afe4a-db44-4582-ba4e-388efc9ae70e" />

## HTTPS
![image](https://github.com/user-attachments/assets/bea67bbd-bcfb-41a6-a075-73ddda19912b)
