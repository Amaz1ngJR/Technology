分层模型
|OSI 七层|	TCP/IP 四层|* TCP/IP 五层	|主要协议|主要职责|
|-----|------------|---------------|-----|----------|
|应用层|	→ 应用层	|→ 应用层	|HTTP, DNS, SMTP, FTP| 用户交互、数据语义|
|表示层	|↗	|↗	| | |
|会话层	|↗	|↗	| | |
|传输层	|→ 传输层	|→ 传输层	|TCP, UDP| 端到端通信、可靠性|
|网络层	|→ 网络层	|→ 网络层	|IP, ICMP, OSPF, BGP| 路由、寻址、跨网段	|
|数据链路层	|↘ 网络接口层	|→ 数据链路层	|Ethernet, Wi-Fi, PPP, ARP|局域网帧传输、MAC 地址	| 
|物理层	|↘ 网络接口层	|→ 物理层	|双绞线、光纤、无线电波、USB| 电信号、光信号、比特流|

网络模型：C/S模型(client-server)和B/S模型(browser-server)
|    |C/S模型(client-server)|B/S模型(browser-server)|
|-----|--------------------|------------------------|
|优点|缓存大量数据、协议选择灵活、速度快|安全性高、跨平台、开发工作量小|
|缺点|安全性不好、不能跨平台、开发工作量大|不能缓存大量数据、严格遵循http|
# 物理层

# 数据链路层
## ARP、RARP协议
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/5c31c69a-a7ab-448d-afff-82d0f3ac80f1)
```
可以相当于以太网帧的特殊的一种
帧首部的类型为0800表示普通的帧 类型为0806表示ARP 8035表示RARP + 【ARP/RARP 请求/应答(28) + PAD(18)凑够以太网帧的最小数据长度46B】
```
```
ARP请求示例：[ff:ff:ff:ff:ff][00:0c:29:9c:e5][0806][8B][00:0c:29:9c:e5][192.168.1.108][ff:ff:ff:ff:ff][192.168.1.111]
ARP应答示例：[00:0c:29:9c:e5][66:0c:29:96:66][0806][8B][66:0c:29:96:66][192.168.1.111][00:0c:29:9c:e5][192.168.1.108]
```
# 网络层
## IP
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/2d9bfb90-c911-4732-9239-895b27917f18)

版本 IPV4/6 TTL设置数据包在路由节点中的跳转上限 每经过一个路由节点该值-1 直到0路由器丢弃
## NAT 网络地址转换
NAT(Network Address Translation)通过将私有IP地址转换为公共IP地址，使多个内部设备能够共享一个或多个公共IP地址访问互联网（解决 IPv4 地址枯竭问题）。私有IP地址通常用于局域网中，不能直接在互联网中路由，而公共IP地址由ISP分配，用于标识设备在互联网中的位置。

NAT 设备（通常是路由器）位于内网与公网之间，当数据包经过时：

- 出站数据包（内网 → 外网）：
    - 修改源 IP 地址为公网 IP；
    - 可选：修改源端口号（PAT 场景）；
    - 在 NAT 表中记录映射关系。
- 入站数据包（外网 → 内网）：
    - 根据目标 IP 和端口查询 NAT 表；
    - 找到对应内网 IP 和端口；
    - 修改目标地址并转发给内网主机。
>NAT转换表（NAT Table）:
存储“内网IP:端口 ↔ 公网IP:端口”的映射关系
### 主要分类

|特性	|静态 NAT	|动态 NAT|	【最常用】PAT（NAPT）|
|-------|--------|--------|-------------|
|映射关系	|1:1 固定|	N:M 临时（IP池）|	N:1（IP+端口）|
|是否转换端口	|❌ 否|	❌ 否|	✅ 是|
|是否节省公网 IP|	❌ 否	|❌ 部分节省（仍需多IP）|	✅✅ 是（一个IP支持多设备）|
|外部可访问性|	✅ 可（如服务器）|	⚠️ 临时可	|❌ 默认不可（除非端口映射）|

#### 静态NAT
静态NAT（Static NAT）是一种一对一的地址转换方式，将一个私有IP地址映射为一个固定的公共IP地址。每个内部设备都对应一个唯一的公共IP地址。
#### 动态NAT
动态NAT（Dynamic NAT）是一种多对多的地址转换方式，将多个私有IP地址动态映射为多个公共IP地址。NAT设备维护一个地址池，并根据需要分配公共IP地址。
#### 端口地址转换（PAT）
端口地址转换（Port Address Translation 也称 NAT Overload）是一种多对一的地址转换方式，允许多个私有 IP 地址共享一个公网 IP 地址；NAT 设备通过为每个“私有IP:端口”分配唯一的“公网IP:端口”映射来区分不同会话 —— 无论是来自不同主机，还是同一主机的不同源端口
端口号有限制【端口号16位，支持的最大主机数约为216】，过多的连接可能导致端口耗尽。

### 行为分类
<img width="654" height="368" alt="image" src="https://github.com/user-attachments/assets/0be9d37d-c0c1-4603-9bd0-452ece69a13a" />

- 锥型 NAT（Cone）：
    - 映射键 = 内网 IP:Port
    - 无论访问多少外部目标，只要“内网IP:Port”相同 → 尽量使用同一个公网端口
    - 外部能否访问取决于“锥型子类”（完全/限制/端口限制）
-  对称型 NAT（Symmetric）：
    - 映射键 = 内网 IP:Port + 外网 IP:Port
    - 同一个“内网IP:Port”，访问不同目标 → 分配不同公网端口

|类型	|映射是否复用端口？|	外部访问限制|	穿透难度|
|-------|--------|--------|-------------|
|完全锥型|	是（固定端口）|	无限制，任意 IP:Port 可访问	|⭐⭐⭐⭐⭐	|
|限制型锥型	|是	|仅访问过的 IP（任意端口）可访问	|⭐⭐⭐⭐	|
|端口限制型锥型	|是	|仅访问过的 IP:Port 可访问	|⭐⭐⭐	|
|对称型 NAT	|❌ 否（不同目标用不同端口）|	仅原目标 IP:Port 可回包	|⭐|

假定：
>公网server1：ip是1.1.1.1，监听端口是1111
公网server2：ip是2.2.2.2，监听端口是2222
NAT网关：ip是3.3.3.3
NAT内部需要穿透的电脑A：内网ip是：192.168.0.2
A（192.168.0.2:100）已经通过NAT网关（3.3.3.3:200）和server1（1.1.1.1:1111）建立了链接

#### 完全锥型
（Full Cone NAT）一旦映射建立，任何外部主机（无论 IP 和端口）都可以向 3.3.3.3:200发送数据包，NAT网关就会接收数据包并将其转发到内部的192.168.0.2:100上
#### ip限制型锥型
（Restricted Cone NAT）只有 A 曾经发送过数据包的“外部 IP”，才能从任意端口向 P 发包并被转发给 A。例如此刻如果server1想通过1112这个端口和A再建立一个连接，那么只需要往3.3.3.3:200发送数据，NAT会正常的将其转发到192.168.0.2:100，但是如果此刻server2想和A建立连接，因为server2在此前并未和A建立连接，所以如果server2给3.3.3.3:200发送数据的话，NAT网关会将来自server2的数据包直接丢弃。
#### 端口限制型锥型 NAT
（Port-Restricted Cone NAT）只有 A 曾经发送过数据包的“外部 IP + 端口”，才能向 P 发包并被转发。在ip限制型锥型的基础上，再进行端口的限制，也就是说现在不只对ip有需求，连端口都有需求，如果按照上面的例子，此刻如果server1还想通过1112端口和A建立连接就不行了，因为限制了端口，只有从1.1.1.1:1111发来的数据NAT网关才会处理
#### 对称型 NAT
（Symmetric NAT）同一个内网 IP:Port，访问不同的外网目标，会映射到不同的公网端口
即：映射关系是 “内网IP:Port + 外网IP:Port” → “公网IP:Port”
# 传输层
## UDP

## TCP
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/17052f06-b147-4e7e-8499-179dc2e242f0)

```
序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题
确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题
控制位：
ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 
RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接
SYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定
FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段
```

### 三次握手与四次挥手
三次握手(发生在内核 用户层面上 客户端connect(第二次握手)和服务器accept(第三次握手)执行完成并返回)
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/3d7ab297-aa22-4872-885c-07e630ba3ae9)
如果TCP连接只有两次握手会怎么样
```
两次握手无法确保客户端的SYN报文确实被服务器接收并响应。客户端在发送SYN后，如果没有收到服务器的SYN+ACK，可能会重传SYN
但在两次握手的模型中，一旦服务器收到任何一个SYN并回应SYN+ACK，连接就被认为建立
这可能导致客户端和服务端对于连接状态的理解不一致，尤其是在网络拥塞或丢包的情况下 如：
客户端的SYN报文在网络中滞留，最终到达服务器时，客户端可能早已放弃连接尝试或已经关闭
服务器收到这样的滞留SYN后，按照两次握手建立连接，但实际上客户端并无连接需求，这会造成服务器端资源（如半开连接队列、缓冲区等）的无谓消耗
```
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/4cd91623-cda9-426c-83f9-ad7853ff00ec)

四次挥手的半关闭状态：正是因为需要两次才能半关闭 所以断开连接是四次握手

socket套接字中有两个(读、写)缓冲区 半关闭就是关闭了其中一个写缓冲区
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/55163018-cfea-44eb-8f63-c368101450d0)

TCP状态转移图
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/12c270d9-53d1-4d57-8dfd-9d7b12503155)

### 可靠传输
```
连接管理：
  三次握手：TCP连接建立过程中，通过三次握手（SYN, SYN-ACK, ACK）确保双方的通信参数协商一致，为后续的数据传输做好准备
  四次挥手：TCP连接关闭时，通过四次挥手（FIN, ACK, FIN, ACK）确保数据传输完成且双方都同意关闭连接，避免数据丢失或资源泄露
序列号与确认应答：
  序列号：TCP为每个发送的数据段（Segment）赋予一个唯一的序列号，确保接收方能够按序重组数据，并检测数据是否丢失或重复
  确认应答：接收方对收到的数据段发送ACK，确认号指出期待接收的下一个数据段的序列号。发送方如果没有收到预期的ACK，会认为数据段可能丢失，并触发重传机制
数据校验：
  校验和：TCP在每个数据段中包含一个校验和字段，用于检测数据在传输过程中是否发生错误。接收方计算收到的数据段的校验和并与段中的校验和字段进行比较，如果不一致则丢弃该段并请求重传
超时重传：
  重传定时器：发送方为每个未确认的数据段设置一个重传定时器。如果在定时器超时前仍未收到ACK，发送方会重新发送该数据段。
  RTO计算：TCP使用自适应算法动态计算RTO值，考虑网络往返时间（RTT）的变化，以适应不同网络条件下的重传时机。
流量控制：
  滑动窗口：TCP使用滑动窗口机制进行流量控制，接收方通过通告窗口大小告诉发送方自己当前能够接收多少数据。发送方必须遵守接收方的窗口限制，避免发送过多数据导致接收方无法处理，造成数据丢失。
  TCP窗口大小调整：根据网络状况和接收方处理能力，动态调整发送窗口大小，以维持高效的数据传输同时避免拥塞。
拥塞控制：
  慢启动：新连接或连接恢复后的初始阶段，TCP使用慢启动算法逐渐增加发送速率，以探测网络的承载能力。
  拥塞避免：当发送速率接近网络极限时，TCP切换到拥塞避免阶段，以更保守的方式逐步增加数据发送量，防止网络过载。
  快速重传与快速恢复：当接收方连续收到多个失序的段时，立即发送重复ACK，触发发送方快速重传未确认的段，同时启动快速恢复算法，避免因重传导致的吞吐量大幅下降。
```
拥塞控制：
![image](https://github.com/user-attachments/assets/db374e2d-7ed9-4970-a193-1d333387b07f)
### 端口问题
TCP和UDP可以使用同一个端口
```
传输层有两个传输协议分别是TCP 和 UDP，在内核中是两个完全独立的软件模块
当主机收到数据包后可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP
所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理
送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理
```
客户端的端口可以重复使用
```
TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的
那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的
所以如果客户端已使用端口9527与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口9527的
```
## RTCP
### NACK
FMT 和 PT 决定了该报文的类型，FCI 则是该类型报文的具体负载 NACK 反馈报文的 PT= 205，FMT=1
<img width="720" height="267" alt="image" src="https://github.com/user-attachments/assets/c2d833c2-a1a4-40a5-aa54-14ef27c5bee7" />

每个FCI 的格式如下（可以附带多个 FCI，通过 header 的 length 字段来标示其长度）：
<img width="1008" height="192" alt="image" src="https://github.com/user-attachments/assets/7d378625-a753-4edc-83e0-59ab82520d8e" />
- PID（Packet identifier），即为丢失的 RTP 数据包的序列号
- BLP（Bitmao of Lost Packets），通过掩码的方式指出了接下来 16 个数据包的丢失情况

c++解析
```c++
// ✅ 使用 getSize() 计算 FCI 块数量
size_t total_bytes = rtcp->getSize();  // 整个 RTCP 包的字节数
if (total_bytes < 12) {
    WarnL << "Invalid RTCP packet size: " << total_bytes;
    break;
}

size_t fci_bytes = total_bytes - 12;  // 减去 4(header) + 4(sender_ssrc) + 4(media_ssrc)
if (fci_bytes == 0 || fci_bytes % 4 != 0) {
    WarnL << "Invalid FCI size: " << fci_bytes << " bytes";
    break;
}

int fci_count = fci_bytes / 4;  // 每个 FCI_NACK 占 4 字节
if (fci_count > 100) { // 添加合理上限检查
    WarnL << "Suspiciously large FCI count: " << fci_count;
    break;
}
InfoL << "Received NACK for media ssrc=" << media_ssrc 
    << ", FCI blocks=" << fci_count;

// --- 🔽 添加：解析并打印 NACK 请求的包序列号 ---
// uint8_t *fci_data = (uint8_t *)(fb + 1);

// 先存储所有请求的NACK序号
std::unordered_set<uint16_t> requested_seq;
uint8_t *fci_data = reinterpret_cast<uint8_t*>(fb) + sizeof(RtcpFB);
std::ostringstream oss;
oss << "NACK requested packets: ";

for (int i = 0; i < fci_count; ++i) {
    uint8_t *ptr = fci_data + i * 4;
    
    // 使用ntohs确保正确的字节序处理
    uint16_t pid = ntohs(*reinterpret_cast<uint16_t*>(ptr));
    uint16_t blp = ntohs(*reinterpret_cast<uint16_t*>(ptr + 2));
    requested_seq.insert(pid);

    oss << "[" << pid;
    for (int j = 0; j < 16; ++j) {
        if (blp & (1 << j)) {
            oss << "," << (pid + 1 + j);
            requested_seq.insert(pid + 1 + j);
        }
    }
    oss << "] ";
}

DebugL << oss.str();
```
# 应用层
## DNS
<img width="1080" height="719" alt="image" src="https://github.com/user-attachments/assets/f8e8017e-f85a-472a-b4e0-165229cb394e" />

## STUN 
STUN (Session Traversal Utilities for NAT)基于 UDP 或 TCP传输，默认端口 3478, 不参与数据传输本身，而是帮助应用程序“发现 NAT 行为”，从而建立 P2P 连接
### 功能
让位于NAT（防火墙）后的客户端发现自己网络的“公网IP:端口”映射对。客户端向公网上的STUN服务器发送一个请求，服务器会回复：“我从哪个公网地址收到了你的请求”。这样，客户端就知道了它在公网上的“联系方式”
- 发现自己的公网 IP 地址和端口（即“NAT 映射后的地址”）；
- 判断自己所处的 NAT 类型（锥型 or 对称型？）；
- 辅助建立点对点（P2P）连接。
>DNS：帮助你“发现 IP 地址” → 为网络层服务；
STUN：帮助你“发现公网地址和 NAT 类型” → 为传输层 P2P 通信服务

STUN 本身不穿透 NAT，它只是“探测和报告”NAT 行为，真正的穿透靠应用程序逻辑或 ICE 协议。
STUN + ICE 可穿透所有锥型 NAT，但对称型 NAT 需要 TURN 中继

### 工作原理
- 1. A 向公网 STUN 服务器（如 stun.l.google.com:3478）发送一个 UDP 请求包；
- 2. STUN 服务器收到包，查看“源 IP:Port”（这是 A 的公网映射地址，如 203.0.113.1:60001）；
- 3. STUN 服务器在响应包中，把 203.0.113.1:60001 告诉 A；
- 4. A 得知：“哦，我在公网的地址是 203.0.113.1:60001”；
- 5. （可选）A 可以再发几次包到不同 IP/Port，测试 NAT 是否复用端口 → 判断 NAT 类型（锥型 or 对称型）。

### STUN 消息结构
```
STUN 消息 = Header + Attributes
Attributes 包含：
  - MAPPED-ADDRESS：你的公网IP:Port
  - XOR-MAPPED-ADDRESS（新版 STUN（RFC 5389））：加密混淆后的地址 防止中间设备篡改
  - ERROR-CODE（如有错误）
  - SOFTWARE（服务器信息）
  - 等等...
```
## TURN
TURN (Traversal Using Relays around NAT) 基于 UDP/TCP/TLS over TCP 或 DTLS传输，默认端口	UDP/TCP 3478，TLS 5349。允许位于严格 NAT（如对称型 NAT）后的客户端，通过公网上的 TURN 服务器中转数据，实现与对端的通信
### 功能
提供一个“公网可达的中继服务器”，A 和 B 都连接到它，所有数据通过它转发，TURN 服务器维护“谁在跟谁通信”的权限表（防止滥用）
### 工作原理
设备 A（内网）和设备 B（内网）无法直连，需通过 TURN 服务器中继通信
1. A 向 TURN 服务器申请“中继地址”
    - A 发送 Allocate 请求（需认证，如用户名/密码或 Token）；
    - TURN 服务器分配一个“中继 IP:Port”（如 185.10.10.1:50000）；
    - 此地址对公网开放，B 可以向它发包。
2. A 告诉 B：“你可以通过 185.10.10.1:50000 找我”
（通常通过信令服务器传递，如 WebSocket、SIP、HTTP）

3. B 向 TURN 服务器的中继地址发包
    - 包到达 TURN 服务器；
    - TURN 查表 → 这是给 A 的 → 转发给 A 的真实地址（通过已建立的 UDP/TCP 隧道）；
4. A → B 的数据也同理：
    - A 发给 TURN 服务器，指明目标是 B；
    - TURN 转发给 B。

### TURN 消息类型
|消息类型	|作用|
|---------|----|
|Allocate	|申请一个中继地址（端口）|
|Refresh	|延长中继地址租期（默认 10 分钟）|
|Send / Data	|发送数据给对端（通过中继）|
|CreatePermission	|授权某个 IP:Port 可以向你发数据（安全控制）|
|ChannelBind	|建立“通道”，用短 ID 代替 IP:Port，减少开销（可选）|
## HTTP
<img width="1080" height="542" alt="image" src="https://github.com/user-attachments/assets/0df2fd5e-7a73-4c09-b364-8aef9132e570" />
HTTP1.0 默认是短连接，HTTP 1.1 默认是长连接，HTTP 2.0 采用的多路复用

说下 HTTP1.0
无状态协议：HTTP 1.0 是无状态的，每个请求之间相互独立，服务器不保存任何请求的状态信息。
非持久连接：默认情况下，每个 HTTP 请求/响应对之后，连接会被关闭，属于短连接。这意味着对于同一个网站的每个资源请求，如 HTML 页面上的图片和脚本，都需要建立一个新的 TCP 连接。可以设置Connection: keep-alive 强制开启长连接。
说下 HTTP1.1
持久连接：HTTP 1.1 引入了持久连接（也称为 HTTP keep-alive），默认情况下不会立即关闭连接，可以在一个连接上发送多个请求和响应。极大减轻了 TCP 连接的开销。
流水线处理：HTTP 1.1 支持客户端在前一个请求的响应到达之前发送下一个请求，以提高传输效率。
说下 HTTP2.0
二进制协议：HTTP 2.0 使用二进制而不是文本格式来传输数据，解析更加高效。
多路复用：一个 TCP 连接上可以同时进行多个 HTTP 请求/响应，解决了 HTTP 1.x 的队头阻塞问题。
头部压缩：HTTP 协议不带状态，所以每次请求都必须附上所有信息。HTTP 2.0 引入了头部压缩机制，可以使用 gzip 或 compress 压缩后再发送，减少了冗余头部信息的带宽消耗。
服务端推送：服务器可以主动向客户端推送资源，而不需要客户端明确请求。
## HTTPS
![image](https://github.com/user-attachments/assets/bea67bbd-bcfb-41a6-a075-73ddda19912b)
