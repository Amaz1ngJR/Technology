UDP用户数据报协议〈User Datagram Protocol)是oSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息.传送服务。
HTTP超文本传输协议（Hyper Text Transfer Protocol〉是互联网上应用最为广泛的一种网络协议。FTP文件传输协议(File Transfer Protocol)
ICMP 协议是Internet 控制报文协议(Internet Control Message Protocol)它是TCP/IP协议族的一个子协议，用于在主机、路由器之间传递控制消息
IGMP协议是Internet组管理协议(Internet Group Management Protocol)，是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间
# 网络基础
协议三要素：语义、语法、时序

## 分层模型、网络模型
OSI模型
```
应用层 HTTP、 File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）协议
表示层
会话层
传输层 TCP/UDP协议
网络层 IP（Internet Protocol）、ICMP（Internet Control Message Protocol）、OSPF、IGMP
数据链路层 ARP协议、RARP 协议
物理层
```
TCP/IP模型
```
应用层 HTTP、FTP、SMTP
传输层 TCP/UDP
网络层 IP、ICMP、OSPF、IGMP
链路层 ARP、RARP
```
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/8a74bda2-d811-4e3f-9d3a-32b4fa0bf16e)
网络模型：C/S模型(client-server)和B/S模型(browser-server)
|    |C/S模型(client-server)|B/S模型(browser-server)|
|-----|--------------------|------------------------|
|优点|缓存大量数据、协议选择灵活、速度快|安全性高、跨平台、开发工作量小|
|缺点|安全性不好、不能跨平台、开发工作量大|不能缓存大量数据、严格遵循http|
## 网络通信
```
数据不进行封装是没法在网络中传输的
主机A向主机B发生数据M 对M进行封装应用层->(剩余都是内核层封装)传输层(段)->网络层(数据报)->链路层(帧) ->网络 主机B逆向解封装获得数据M
```
```
应用层                                                           【首部】【用户数据】
TCP段                                              【TCP首部(20)】【应用数据】
IP数据报                              【IP首部(20)】【TCP首部(20)】【应用数据】
以太网帧     【以太网首部(14)】        【IP首部(20)】【TCP首部(20)】【应用数据】【以太网尾部(4)】
=>【目的MAC地址(6)源MAC地址(6)类型(2)】【数据(46-1500字节)】                   【CRC(4)】 MAC地址(物理地址)全球唯一
```
**从键入URL到网页显示 期间发生了什么**
```
1. 通过浏览器解析URL(https://www.example.com/path/to/page?query=param)各个组成部分：协议//域名 路径 查询参数
2. DNS解析：浏览器先向本地DNS服务器询问www.example.com的IP是啥 如果本地DNS服务器缓存中能够找到 则直接返回其IP 否则就去递归的询问
根DNS服务器（.）顶级域DNS服务器（.com）权威DNS服务器（server.com）权威DNS服务器将查询到的IP结果告诉本地DNS 本地DNS做相应的缓存
3. 通过DNS获取IP后 使用URL中指定的协议(http)与服务器建立TCP连接
4. 建立TCP连接后 浏览器构造并发送一个HTTP请求 请求中包含以下信息：
方法（如GET、POST等）：指示要执行的操作类型。
    请求URI（如 /path/to/page?query=param）：基于URL中的路径和查询参数。
    HTTP头：包含诸如主机名、接受的内容类型、认证信息、缓存控制指令等元数据。
    请求体（如适用）：对于POST等方法，可能包含提交的数据
5.服务器处理请求
6.服务器生成响应 服务器构造一个HTTP响应发送回浏览器。响应包括：
    状态码：表示请求的处理结果（如200 OK、404 Not Found等）。
    响应头：类似于请求头，包含服务器信息、内容类型、缓存控制指令、编码等。
    响应体：实际的网页内容，通常是HTML文档，也可能包含JSON、XML或其他格式的数据。
。。。
```
# ARP、RARP协议
```
ARP协议是正向地址解析协议(Address Resolution Protocol)工作在数据链路层之上 帮助解决网络层(IP层)地址到数据链路层地址的映射问题
*通过已知的IP 寻找对应主机的MAc地址 用于将IP地址解析为对应的物理硬件地址(如MAC地址)
在同一网络中的设备通过已知的IP地址查找相应的MAC地址 以便正确地将数据帧发送到目标设备
```
```
可以相当于以太网帧的特殊的一种
帧首部的类型为0800表示普通的帧 类型为0806表示ARP 8035表示RARP + 【ARP/RARP 请求/应答(28) + PAD(18)凑够以太网帧的最小数据长度46B】
```
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/5c31c69a-a7ab-448d-afff-82d0f3ac80f1)
```
ARP请求示例：[ff:ff:ff:ff:ff][00:0c:29:9c:e5][0806][8B][00:0c:29:9c:e5][192.168.1.108][ff:ff:ff:ff:ff][192.168.1.111]
ARP应答示例：[00:0c:29:9c:e5][66:0c:29:96:66][0806][8B][66:0c:29:96:66][192.168.1.111][00:0c:29:9c:e5][192.168.1.108]
```
```
RARP协议也工作在数据链路层之上 与ARP相反 用于将已知的物理硬件地址(如MAC地址)解析为对应的IP地址 通常 RARP在启动时由计算机向网络上的RARP服务器请求其IP地址
```

# IP协议
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/2d9bfb90-c911-4732-9239-895b27917f18)
```
版本 IPV4/6 TTL设置数据包在路由节点中的跳转上限 每经过一个路由节点该值-1 直到0路由器丢弃
```
# TCP/UDP
TCP传输控制协议(Transmission Control Protocol)是一种面向连接的、可靠的、基于字节流的传输层通信协议
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/17052f06-b147-4e7e-8499-179dc2e242f0)
```
序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题
确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题
控制位：
ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 
RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接
SYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定
FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段
```

三次握手(发生在内核 用户层面上 客户端connect和服务器accept执行完成并返回)

四次挥手 先两次实现客户端半关闭(客户端不能发送数据了 但能接受服务器发来的数据)

![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/033e1657-0e5d-41fd-942f-32ec9d22fd65)

最后客户端会等待2MSL的时长才关闭连接 保证最后一个ACK能成功被对端接收

四次挥手的半关闭状态：正是因为需要两次才能半关闭 所以断开连接是四次握手

socket套接字中有两个(读、写)缓冲区 半关闭就是关闭了其中一个写缓冲区
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/55163018-cfea-44eb-8f63-c368101450d0)

TCP状态转移图
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/12c270d9-53d1-4d57-8dfd-9d7b12503155)

TCP如何实现可靠传输的？
```
连接管理：
  三次握手：TCP连接建立过程中，通过三次握手（SYN, SYN-ACK, ACK）确保双方的通信参数协商一致，为后续的数据传输做好准备
  四次挥手：TCP连接关闭时，通过四次挥手（FIN, ACK, FIN, ACK）确保数据传输完成且双方都同意关闭连接，避免数据丢失或资源泄露
序列号与确认应答：
  序列号：TCP为每个发送的数据段（Segment）赋予一个唯一的序列号，确保接收方能够按序重组数据，并检测数据是否丢失或重复
  确认应答：接收方对收到的数据段发送ACK，确认号指出期待接收的下一个数据段的序列号。发送方如果没有收到预期的ACK，会认为数据段可能丢失，并触发重传机制
数据校验：
  校验和：TCP在每个数据段中包含一个校验和字段，用于检测数据在传输过程中是否发生错误。接收方计算收到的数据段的校验和并与段中的校验和字段进行比较，如果不一致则丢弃该段并请求重传
超时重传：
  重传定时器：发送方为每个未确认的数据段设置一个重传定时器。如果在定时器超时前仍未收到ACK，发送方会重新发送该数据段。
  RTO计算：TCP使用自适应算法动态计算RTO值，考虑网络往返时间（RTT）的变化，以适应不同网络条件下的重传时机。
流量控制：
  滑动窗口：TCP使用滑动窗口机制进行流量控制，接收方通过通告窗口大小告诉发送方自己当前能够接收多少数据。发送方必须遵守接收方的窗口限制，避免发送过多数据导致接收方无法处理，造成数据丢失。
  TCP窗口大小调整：根据网络状况和接收方处理能力，动态调整发送窗口大小，以维持高效的数据传输同时避免拥塞。
拥塞控制：
  慢启动：新连接或连接恢复后的初始阶段，TCP使用慢启动算法逐渐增加发送速率，以探测网络的承载能力。
  拥塞避免：当发送速率接近网络极限时，TCP切换到拥塞避免阶段，以更保守的方式逐步增加数据发送量，防止网络过载。
  快速重传与快速恢复：当接收方连续收到多个失序的段时，立即发送重复ACK，触发发送方快速重传未确认的段，同时启动快速恢复算法，避免因重传导致的吞吐量大幅下降。
```

# HTTP、HTTPS
HTTP是超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议；
```
无状态：HTTP协议本身不对请求和响应之间的通信状态进行保存。这意味着每次请求都是独立的，服务器不会记住之前客户端的请求历史。若需要保持状态，通常需要借助Cookies、Session等技术
明文传输：HTTP协议在传输数据时不进行加密，所有请求和响应的内容（包括URL、请求头、请求体、响应头、响应体）均以明文形式在网络中传输，容易被中间人监听、篡改或冒充
简单快速：HTTP协议设计简单，报文结构清晰，解析和生成成本较低，有利于快速处理和响应请求
```
HTTPS是HTTP协议的安全版本，通过在HTTP协议与TCP协议之间增加一层SSL/TLS协议，为数据通信提供加密、认证和完整性保护。
```
加密通信：HTTPS使用SSL/TLS协议对请求和响应内容进行加密，包括但不限于URL、请求头、请求体、响应头、响应体
加密方式通常采用对称加密（如AES）与非对称加密（如RSA）相结合的混合加密模式，保证数据在传输过程中即使被截获也无法被轻易解读
身份认证：服务器在HTTPS连接建立阶段会向客户端出示数字证书，包含服务器的身份信息（如域名、颁发机构、公钥等）
客户端通过验证证书的完整性和可信性来确认服务器的身份，防止中间人攻击和假冒服务器
数据完整性：HTTPS通过消息认证码（MAC）或数字签名技术，确保数据在传输过程中未经篡改。如果数据在传输过程中被修改，接收方能够检测出来并拒绝接收
```
## HTTP与HTTPS的区别
```
安全性：这是二者最显著的区别。HTTP是超文本传输协议，信息是明文传输，存在安全风险的问题，通信内容易被窃听、篡改。
而HTTPS 在TCP和HTTP网络层之间加入了SSL/TLS安全协议 使得报文能够加密传输。
建立连接：HTTP在TCP三次握手后就可以进行报文传输而HTTPS在TCP三次握手之后还需要进行SSL/TLS的握手，才可以进入加密报文传输
端口：HTTP默认使用TCP端口80，而HTTPS使用端口443
性能：由于HTTPS需要进行加密、解密操作以及证书验证，相比HTTP会引入额外的计算和网络延迟 HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的
```
**SSL/TLS的核心功能**
```
数据混合加密：通过使用对称加密和非对称加密(公匙加密)混合加密 确保传输过程中数据以密文形式存在
    通信建立前采用非对称加密的方式交换「会话秘钥」 后续就不再使用非对称加密
    （非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢）
    通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据
    （对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换）
身份验证：通过证书体系 验证通信双方的身份 服务端的身份验证是强制的
完整性保护：使用消息认证码(MAC)或者摘要算法(哈希函数)确保数据在传输过程中未经篡改
```
## get和post的区别
```
请求方法的目的：
GET：用于请求获取指定资源 是「只读」操作。它向服务器询问特定的 URL 并请求返回与之相关的数据
GET 请求主要用于数据查询、读取操作，且应该是安全的（即不改变服务器状态）和幂等的（多次请求同样的资源应该得到相同的结果）
POST：用于向指定资源提交数据，请求服务器进行处理（如数据新增、更新等）。POST 请求可能会导致服务器状态的改变，例如创建新资源、更新现有资源或触发一系列业务逻辑
```
## http缓存技术
```

```
