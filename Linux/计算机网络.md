UDP用户数据报协议〈User Datagram Protocol)是oSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息.传送服务。
HTTP超文本传输协议（Hyper Text Transfer Protocol〉是互联网上应用最为广泛的一种网络协议。FTP文件传输协议(File Transfer Protocol)
ICMP 协议是Internet 控制报文协议(Internet Control Message Protocol)它是TCP/IP协议族的一个子协议，用于在主机、路由器之间传递控制消息
IGMP协议是Internet组管理协议(Internet Group Management Protocol)，是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间
# 网络基础
协议三要素：语义、语法、时序

## 分层模型、网络模型
OSI模型
```
应用层 HTTP、 FTP、SMTP（Simple Mail Transfer Protocol）协议
表示层
会话层
传输层 TCP/UDP协议
网络层 IP（Internet Protocol）、ICMP（Internet Control Message Protocol）、OSPF、IGMP
数据链路层 ARP协议、RARP 协议
物理层
```
TCP/IP模型
```
应用层 HTTP、FTP、SMTP
传输层 TCP/UDP
网络层 IP、ICMP、OSPF、IGMP
链路层 ARP、RARP
```
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/8a74bda2-d811-4e3f-9d3a-32b4fa0bf16e)
网络模型：C/S模型(client-server)和B/S模型(browser-server)
|    |C/S模型(client-server)|B/S模型(browser-server)|
|-----|--------------------|------------------------|
|优点|缓存大量数据、协议选择灵活、速度快|安全性高、跨平台、开发工作量小|
|缺点|安全性不好、不能跨平台、开发工作量大|不能缓存大量数据、严格遵循http|
## 网络通信
```
数据不进行封装是没法在网络中传输的
主机A向主机B发生数据M 对M进行封装应用层->(剩余都是内核层封装)传输层(段)->网络层(数据报)->链路层(帧) ->网络 主机B逆向解封装获得数据M
```
```
应用层                                                           【首部】【用户数据】
TCP段                                              【TCP首部(20)】【应用数据】
IP数据报                              【IP首部(20)】【TCP首部(20)】【应用数据】
以太网帧     【以太网首部(14)】        【IP首部(20)】【TCP首部(20)】【应用数据】【以太网尾部(4)】
=>【目的MAC地址(6)源MAC地址(6)类型(2)】【数据(46-1500字节)】                   【CRC(4)】 MAC地址(物理地址)全球唯一
```
**从键入URL到网页显示 期间发生了什么**
```
1. 通过浏览器解析URL(https://www.example.com/path/to/page?query=param)各个组成部分：协议//域名 路径 查询参数
2. DNS解析：浏览器先向本地DNS服务器询问www.example.com的IP是啥 如果本地DNS服务器缓存中能够找到 则直接返回其IP 否则就去递归的询问
根DNS服务器（.）顶级域DNS服务器（.com）权威DNS服务器（server.com）权威DNS服务器将查询到的IP结果告诉本地DNS 本地DNS做相应的缓存
3. 通过DNS获取IP后 使用URL中指定的协议(http)与服务器建立TCP连接
4. 建立TCP连接后 浏览器构造并发送一个HTTP请求 请求中包含以下信息：
    方法（如GET、POST等）：指示要执行的操作类型。
    请求URI（如 /path/to/page?query=param）：基于URL中的路径和查询参数。
    HTTP头：包含诸如主机名、接受的内容类型、认证信息、缓存控制指令等元数据。
    请求体（如适用）：对于POST等方法，可能包含提交的数据
5.服务器处理请求 生成响应 服务器构造一个HTTP响应发送回浏览器。响应包括：
    状态码：表示请求的处理结果（如200 OK、404 Not Found等）。
    响应头：类似于请求头，包含服务器信息、内容类型、缓存控制指令、编码等。
    响应体：实际的网页内容，通常是HTML文档，也可能包含JSON、XML或其他格式的数据。
。。。
```
# ARP、RARP协议
```
ARP协议是正向地址解析协议(Address Resolution Protocol)工作在数据链路层之上 帮助解决网络层(IP层)地址到数据链路层地址的映射问题
*通过已知的IP 寻找对应主机的MAc地址 用于将IP地址解析为对应的物理硬件地址(如MAC地址)
在同一网络中的设备通过已知的IP地址查找相应的MAC地址 以便正确地将数据帧发送到目标设备
```
```
可以相当于以太网帧的特殊的一种
帧首部的类型为0800表示普通的帧 类型为0806表示ARP 8035表示RARP + 【ARP/RARP 请求/应答(28) + PAD(18)凑够以太网帧的最小数据长度46B】
```
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/5c31c69a-a7ab-448d-afff-82d0f3ac80f1)
```
ARP请求示例：[ff:ff:ff:ff:ff][00:0c:29:9c:e5][0806][8B][00:0c:29:9c:e5][192.168.1.108][ff:ff:ff:ff:ff][192.168.1.111]
ARP应答示例：[00:0c:29:9c:e5][66:0c:29:96:66][0806][8B][66:0c:29:96:66][192.168.1.111][00:0c:29:9c:e5][192.168.1.108]
```
```
RARP协议也工作在数据链路层之上 与ARP相反 用于将已知的物理硬件地址(如MAC地址)解析为对应的IP地址 通常 RARP在启动时由计算机向网络上的RARP服务器请求其IP地址
```

# IP协议
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/2d9bfb90-c911-4732-9239-895b27917f18)
```
版本 IPV4/6 TTL设置数据包在路由节点中的跳转上限 每经过一个路由节点该值-1 直到0路由器丢弃
```
# TCP/UDP
TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议

UDP是一种无连接的、不可靠的、基于数据报的传输层通信协议
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/17052f06-b147-4e7e-8499-179dc2e242f0)
```
序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题
确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题
控制位：
ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 
RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接
SYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定
FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段
```
## 基于TCP/UDP的协议
基于TCP的协议：
```
HTTP、HTTPS、FTP、SMTP、POP3、IMAP、SSH、Telnet、NNTP、LDAP  
```
基于UDP的协议：
```
DNS、TFTP、RIP、DHCP、SNMP、BOOTP、NTP、SDP、IGMP
```
## 端口问题
TCP和UDP可以使用同一个
```
传输层有两个传输协议分别是TCP 和 UDP，在内核中是两个完全独立的软件模块
当主机收到数据包后可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP
所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理
送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理
```
客户端的端口可以重复使用
```
TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的
那么只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的
所以如果客户端已使用端口9527与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口9527的
```
## 三次握手与四次挥手
三次握手(发生在内核 用户层面上 客户端connect(第二次握手)和服务器accept(第三次握手)执行完成并返回)
```
第一次握手：客户端发起连接请求（SYN）
客户端生成一个随机的初始序列号（ISN），记作seq = X 并构造一个TCP报文段，设置标志位（Flags）中的SYN（同步）为1，
表示这是一个连接请求报文。其他字段如源端口、目的端口、窗口大小等也被正确填写
将这个SYN报文段发送给服务器 然后进入SYN_SENT状态，等待服务器的响应
第二次握手：服务器确认连接请求并同步序列号（SYN+ACK）
服务器接收到客户端发来的SYN报文段后 为这次连接也生成一个随机的初始序列号，记作seq = Y
并构造一个TCP报文段作为响应，设置SYN=1（表示同步请求）、ACK=1（表示确认）
将确认号设置为ack = X + 1，表示它期望收到客户端下一个报文段的序列号 将自己的序列号seq = Y放入报文段中
将这个SYN+ACK报文段发送给客户端 并进入SYN_RCVD状态，等待客户端的确认
第三次握手：客户端确认连接（ACK）
客户端接收到服务器的SYN+ACK报文段后，验证确认号ack = X + 1是否正确
客户端再次构造一个TCP报文段，此时仅设置ACK=1（确认），确认号为ack = Y + 1 序列号seq则为X + 1
客户端和服务器都进入ESTABLISHED状态，连接建立成功
```
如果TCP连接只有两次握手会怎么样
```
两次握手无法确保客户端的SYN报文确实被服务器接收并响应。客户端在发送SYN后，如果没有收到服务器的SYN+ACK，可能会重传SYN
但在两次握手的模型中，一旦服务器收到任何一个SYN并回应SYN+ACK，连接就被认为建立
这可能导致客户端和服务端对于连接状态的理解不一致，尤其是在网络拥塞或丢包的情况下 如：
客户端的SYN报文在网络中滞留，最终到达服务器时，客户端可能早已放弃连接尝试或已经关闭
服务器收到这样的滞留SYN后，按照两次握手建立连接，但实际上客户端并无连接需求，这会造成服务器端资源（如半开连接队列、缓冲区等）的无谓消耗
```
四次挥手 先两次实现客户端半关闭(客户端不能发送数据了 但能接受服务器发来的数据)

![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/3d7ab297-aa22-4872-885c-07e630ba3ae9)

四次挥手
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/4cd91623-cda9-426c-83f9-ad7853ff00ec)
```
第一次挥手，客户端调用 close 表明客户端没有数据需要发送了 则此时会向服务端发送 FIN 报文 进入 FIN_WAIT_1 状态
服务端接收到了 FIN 报文(TCP协议栈会为FIN包插入一个文件结束符EOF到接收缓冲区中)
应用程序可以通过 read调用感知这个FIN后进行第二次挥手
这个 EOF 会被放在已排队等候的其他已接收的数据之后 这意味着服务端需要处理这种异常情况  此时服务端进入 CLOSE_WAIT 状态；
服务端处理完数据后读到 EOF 于是也调用 close 关闭它的套接字 这会使得服务端发出一个 FIN 包进入第三次挥手之后处于 LAST_ACK 状态
客户端接收到服务端的 FIN 包 并发送 ACK 确认包给服务端进行第四次挥手 此时客户端将进入 TIME_WAIT 状态
服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态
最后客户端会等待2MSL的时长才也进入 CLOSE 状态 关闭连接 保证最后一个ACK能成功被对端接收
```
四次挥手的半关闭状态：正是因为需要两次才能半关闭 所以断开连接是四次握手

socket套接字中有两个(读、写)缓冲区 半关闭就是关闭了其中一个写缓冲区
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/55163018-cfea-44eb-8f63-c368101450d0)

TCP状态转移图
![image](https://github.com/Amaz1ngJR/Technology/assets/83129567/12c270d9-53d1-4d57-8dfd-9d7b12503155)

## TCP如何实现可靠传输
```
连接管理：
  三次握手：TCP连接建立过程中，通过三次握手（SYN, SYN-ACK, ACK）确保双方的通信参数协商一致，为后续的数据传输做好准备
  四次挥手：TCP连接关闭时，通过四次挥手（FIN, ACK, FIN, ACK）确保数据传输完成且双方都同意关闭连接，避免数据丢失或资源泄露
序列号与确认应答：
  序列号：TCP为每个发送的数据段（Segment）赋予一个唯一的序列号，确保接收方能够按序重组数据，并检测数据是否丢失或重复
  确认应答：接收方对收到的数据段发送ACK，确认号指出期待接收的下一个数据段的序列号。发送方如果没有收到预期的ACK，会认为数据段可能丢失，并触发重传机制
数据校验：
  校验和：TCP在每个数据段中包含一个校验和字段，用于检测数据在传输过程中是否发生错误。接收方计算收到的数据段的校验和并与段中的校验和字段进行比较，如果不一致则丢弃该段并请求重传
超时重传：
  重传定时器：发送方为每个未确认的数据段设置一个重传定时器。如果在定时器超时前仍未收到ACK，发送方会重新发送该数据段。
  RTO计算：TCP使用自适应算法动态计算RTO值，考虑网络往返时间（RTT）的变化，以适应不同网络条件下的重传时机。
流量控制：
  滑动窗口：TCP使用滑动窗口机制进行流量控制，接收方通过通告窗口大小告诉发送方自己当前能够接收多少数据。发送方必须遵守接收方的窗口限制，避免发送过多数据导致接收方无法处理，造成数据丢失。
  TCP窗口大小调整：根据网络状况和接收方处理能力，动态调整发送窗口大小，以维持高效的数据传输同时避免拥塞。
拥塞控制：
  慢启动：新连接或连接恢复后的初始阶段，TCP使用慢启动算法逐渐增加发送速率，以探测网络的承载能力。
  拥塞避免：当发送速率接近网络极限时，TCP切换到拥塞避免阶段，以更保守的方式逐步增加数据发送量，防止网络过载。
  快速重传与快速恢复：当接收方连续收到多个失序的段时，立即发送重复ACK，触发发送方快速重传未确认的段，同时启动快速恢复算法，避免因重传导致的吞吐量大幅下降。
```
拥塞控制：
![image](https://github.com/user-attachments/assets/db374e2d-7ed9-4970-a193-1d333387b07f)

## 基于UDP实现可靠传输QUIC

# HTTP、HTTPS
HTTP是超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议；
```
无状态：HTTP协议本身不对请求和响应之间的通信状态进行保存。这意味着每次请求都是独立的，服务器不会记住之前客户端的请求历史。若需要保持状态，通常需要借助Cookies、Session等技术
明文传输：HTTP协议在传输数据时不进行加密，所有请求和响应的内容（包括URL、请求头、请求体、响应头、响应体）均以明文形式在网络中传输，容易被中间人监听、篡改或冒充
简单快速：HTTP协议设计简单，报文结构清晰，解析和生成成本较低，有利于快速处理和响应请求
```
HTTPS是HTTP协议的安全版本，通过在HTTP协议与TCP协议之间增加一层SSL/TLS协议，为数据通信提供加密、认证和完整性保护。
```
加密通信：HTTPS使用SSL/TLS协议对请求和响应内容进行加密，包括但不限于URL、请求头、请求体、响应头、响应体
    加密方式通常采用对称加密（如AES）与非对称加密（如RSA）相结合的混合加密模式
    通信建立前采用非对称加密的方式交换「会话秘钥」
    通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据
身份认证：服务器在HTTPS连接建立阶段会向客户端出示数字证书，包含服务器的身份信息（如域名、颁发机构、公钥等）
客户端通过验证证书的完整性和可信性来确认服务器的身份，防止中间人攻击和假冒服务器
数据完整性：HTTPS通过消息认证码（MAC）或数字签名技术，确保数据在传输过程中未经篡改。如果数据在传输过程中被修改，接收方能够检测出来并拒绝接收
```
## HTTP1.0 1.1 2.0 3.0
HTTP1.0 默认短连接，HTTP 1.1 默认长连接，HTTP 2.0 采用多路复用

**HTTP1.0**

无状态协议：HTTP 1.0 是无状态的，每个请求之间相互独立，服务器不保存任何请求的状态信息。

非持久连接：默认情况下，每个 HTTP 请求/响应对之后，连接会被关闭，属于短连接。这意味着对于同一个网站的每个资源请求，如 HTML 页面上的图片和脚本，都需要建立一个新的 TCP 连接。可以设置Connection: keep-alive 强制开启长连接。

**HTTP1.1**

持久连接：HTTP 1.1 引入了持久连接（也称为 HTTP keep-alive），默认情况下不会立即关闭连接，可以在一个连接上发送多个请求和响应。极大减轻了 TCP 连接的开销。

流水线处理：HTTP 1.1 支持客户端在前一个请求的响应到达之前发送下一个请求，以提高传输效率。

**HTTP2.0**

二进制协议：HTTP 2.0 使用二进制而不是文本格式来传输数据，解析更加高效。

多路复用：一个 TCP 连接上可以同时进行多个 HTTP 请求/响应，解决了 HTTP 1.x 的队头阻塞问题。

头部压缩：HTTP 协议不带状态，所以每次请求都必须附上所有信息。HTTP 2.0 引入了头部压缩机制，可以使用 gzip 或 compress 压缩后再发送，减少了冗余头部信息的带宽消耗。

服务端推送：服务器可以主动向客户端推送资源，而不需要客户端明确请求。

**HTTP/3.0**

 基于 QUIC (UDP)协议，Quick UDP Connections，直译为快速 UDP 网络连接。
 
## HTTP与HTTPS的区别
```
安全性：这是二者最显著的区别。HTTP是超文本传输协议，信息是明文传输，存在安全风险的问题，通信内容易被窃听、篡改。
而HTTPS 在TCP和HTTP网络层之间加入了SSL/TLS安全协议 使得报文能够加密传输。
建立连接：HTTP在TCP三次握手后就可以进行报文传输而HTTPS在TCP三次握手之后还需要进行SSL/TLS的握手，才可以进入加密报文传输
端口：HTTP默认使用TCP端口80，而HTTPS使用端口443
性能：由于HTTPS需要进行加密、解密操作以及证书验证，相比HTTP会引入额外的计算和网络延迟 HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的
```
![image](https://github.com/user-attachments/assets/bea67bbd-bcfb-41a6-a075-73ddda19912b)

```
HTTPS 的连接建立在 SSL/TLS 握手之上，其过程可以分为两个阶段：握手阶段和数据传输阶段。

①、客户端向服务器发起请求

②、服务器接收到请求后，返回自己的数字证书，包含了公钥、颁发机构等信息。

③、客户端收到服务器的证书后，验证证书的合法性，如果合法，会生成一个随机码，然后用服务器的公钥加密这个随机码，发送给服务器。

④、服务器收到会话密钥后，用私钥解密，得到会话密钥。

⑤、客户端和服务器通过会话密码对通信内容进行加密，然后传输。

如果通信内容被截取，但由于没有会话密钥，所以无法解密。当通信结束后，连接会被关闭，会话密钥也会被销毁，下次通信会重新生成一个会话密钥。
```
**SSL/TLS的核心功能**
```
数据混合加密：通过使用对称加密和非对称加密(公匙加密)混合加密 确保传输过程中数据以密文形式存在
    通信建立前采用非对称加密的方式交换「会话秘钥」 后续就不再使用非对称加密
    （非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢）
    通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据
    （对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换）
身份验证：通过证书体系 验证通信双方的身份 服务端的身份验证是强制的
完整性保护：使用消息认证码(MAC)或者摘要算法(哈希函数)确保数据在传输过程中未经篡改
```
**SSL/TLS四次握手**
```
第一次握手：
先进行TCP连接请求 客户端发送一个TLS消息给服务器 这个消息包含：
    版本信息：客户端支持的最高版本的TLS协议
    随机数：客户端生成的一个随机数，用于后续生成会话密钥
    密码套件列表：客户端支持的一系列加密算法组合（如RSA、ECDHE密钥交换算法搭配AES、ChaCha20等对称加密算法以及SHA、SHA-2等散列函数
    压缩方法：客户端支持的压缩算法（如NULL表示不压缩，DEFLATE表示使用DEFLATE压缩）
    可选扩展：可能还包括扩展字段
第二次握手：
服务器响应 服务器根据自身的配置和客户端提供的信息选择合适的协议版本、密码套件和压缩方法，生成响应
服务器返回一个消息给客户端 这个消息包括：
    选定的版本：服务器选择的TLS协议版本
    随机数：服务器生成的一个随机数，同样用于后续生成会话密钥
    选定的密码套件：服务器从客户端提供的列表中选择一个双方都支持的加密算法组合
    选定的压缩方法：服务器确定的压缩算法
    可能的扩展：如有需要，也包含服务器选定的扩展信息
发送服务器证书：服务器发送其数字证书，其中包括服务器的身份信息（如公钥、证书颁发机构签名、有效期等）。此证书经过受信任的证书颁发机构（CA）签名，客户端可以据此验证服务器的身份
可能的附加消息如：
    服务器密钥交换消息：对于基于公钥的密钥交换算法，服务器发送相应的消息
    证书链（可选）：除服务器证书外，可能还包括中间CA证书以帮助客户端构建完整的信任链
    证书请求（可选）：如果服务器需要验证客户端身份（双向认证），会请求客户端证书
    ServerHello Done消息：标志着服务器握手消息的结束
第三次握手：
客户端验证与密钥交换：客户端验证服务器证书的有效性（包括证书链完整性、CA信任、证书有效期等），然后使用服务器证书中的公钥（或其他密钥交换信息）与自己的随机数一起计算出预主密钥（Pre-Master Secret），进而衍生出会话密钥
发送ClientKeyExchange消息：客户端将密钥交换所需的信息发送给服务器，具体内容取决于所选的密钥交换算法
ChangeCipherSpec协议：客户端发送一个特殊的ChangeCipherSpec消息，告知服务器接下来的通信将启用协商好的加密参数进行保护
发送Finished消息：客户端使用新生成的会话密钥加密一个Finished消息发送给服务器，其中包含了握手过程中的所有消息摘要，用于验证握手过程的完整性和一致性
第四次握手(可选)：
服务器确认切换加密：服务器收到ChangeCipherSpec后，也切换到新的加密参数
发送Finished消息：服务器同样使用会话密钥加密一个Finished消息发送给客户端，包含其侧握手过程的消息摘要
```
## get和post的区别
```
请求方法的目的：
GET：用于请求获取指定资源 是「只读」操作。它向服务器询问特定的 URL 并请求返回与之相关的数据
GET 请求主要用于数据查询、读取操作，且应该是安全的（即不改变服务器状态）和幂等的（多次请求同样的资源应该得到相同的结果）
POST：用于向指定资源提交数据，请求服务器进行处理（如数据新增、更新等）。POST 请求可能会导致服务器状态的改变，例如创建新资源、更新现有资源或触发一系列业务逻辑
```
## http缓存技术
```

```
